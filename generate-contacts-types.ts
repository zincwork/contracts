// Taken from https://github.com/hellobloom/core/blob/2bd20a9096c0e3bafa0c5d3fb168a130573402a3/generate.ts
// with some modifications

interface ConstructorMember {
  inputs: FunctionMemberInput[]
  payable: false
  type: "constructor"
}

interface EventMember {
  inputs: FunctionMemberInput[]
  name: string
  type: "event"
}

interface FunctionMember {
  inputs: FunctionMemberInput[]
  outputs: FunctionMemberInput[]
  name: string
  constant: boolean
  payable: boolean
  type: "function"
}

interface FallbackMember {
  type: "fallback"
  payable: boolean
}

interface UnknownMember {
  type: string
}

type SolidityType =
  | "address"
  | "address[]"
  | "bool"
  | "bytes"
  | "bytes32"
  | "bytes32[]"
  | "string"
  | "uint8"
  | "uint8[]"
  | "uint32"
  | "uint64"
  | "uint256"
  | "uint256[]"

interface FunctionMemberInput {
  name: string
  type: SolidityType
}

type Member = ConstructorMember | EventMember | FunctionMember | FallbackMember

type Abi = (EventMember | FunctionMember | ConstructorMember)[]

interface Definition {
  contractName: string
  abi: Abi
}

function generateHeader(): string {
  return `
    // Autogenerated file
    // DO NOT EDIT!!!
    // You can update it by running \`yarn generate-types\`

    import * as Web3 from "web3";
    import * as BigNumber from "bignumber.js";

    type Address = string;
    type TransactionOptions = Partial<Transaction>;
    type UInt = number | BigNumber.BigNumber;

    interface Transaction {
      hash: string;
      nonce: number;
      blockHash: string | null;
      blockNumber: number | null;
      transactionIndex: number | null;
      from: Address | ContractInstance;
      to: string | null;
      value: UInt;
      gasPrice: UInt;
      gas: number;
      input: string;
    }

    interface ContractInstance {
      address: string;
      sendTransaction(options?: TransactionOptions): Promise<void>;
    }
  `
}

function generateFooter(contractInstances: string[]): string {
  let result = `
    declare type _contractTest = (accounts: string[]) => void;
    declare interface TransactionMeta {
      from: string,
    }

    interface Artifacts {`

  for (const contract of contractInstances) {
    result = result.concat(
      `require(name: "${contract}"): ${contract}Contract\n`
    )
  }

  const end = `
  }

  declare global {
    var artifacts: Artifacts
    var web3: Web3
    function contract(name: string, test: _contractTest): void
    function it(name: string, test: (accounts: string[]) => void): void
  }
    `

  return result.concat(end)
}

function buildContract(definition: Definition) {
  return `
    export interface ${
      definition.contractName
    }Instance extends ContractInstance {
      ${buildMembers(definition.abi)}
    }

    export interface ${definition.contractName}Contract {
      new: (${buildConstructorArguments(definition.abi)}) => Promise<${
    definition.contractName
  }Instance>;
      deployed(): Promise<${definition.contractName}Instance>;
      at(address: string): ${definition.contractName}Instance;
    }
  `
}

function buildMembers(abi: Abi): string {
  return abi.map(buildMember).join("\n")
}

function buildMember(member: Member): string {
  switch (member.type) {
    case "function":
      return buildFunctionMember(member)
    case "event":
      return buildEventMember(member)
    case "constructor":
      return buildConstructorMember(member)
    case "fallback":
      return buildFallbackMember(member)
    default:
      throw "Exhaustiveness miss!"
  }
}

function buildConstructorArguments(abi: Abi): string {
  const constructorMember = abi.find((member) => member.type === "constructor")

  if (!constructorMember) {
    return ""
  }

  return constructorMember.inputs.map(buildFunctionArgument).join(", ")
}

function buildFunctionMember(member: FunctionMember) {
  let args = member.inputs.map(buildFunctionArgument).join(", ")

  if (args.length > 0) {
    args += ", "
  }

  const functionSignature = `(${args}options?: TransactionOptions)`
  return `${member.name}: {
    ${functionSignature}: Promise<Web3.TransactionReceipt>
    call:${functionSignature} => ${translateOutputs(member.outputs)}
    estimateGas: (
      subject: string,
      issuer: string,
      id: string,
      key: string,
      data?: string,
      options?: {
        from?: string
        gas?: number
      }
    ) => number
  }`
}

function translateOutputs(outputs: FunctionMemberInput[]) {
  let valueType
  if (outputs.length === 1) {
    valueType = translateOutput(outputs[0])
  } else if (outputs.length === 0) {
    valueType = "Web3.TransactionReceipt"
  } else {
    valueType = `[${outputs.map(translateOutput).join(", ")}]`
  }

  return `Promise<${valueType}>`
}

function translateOutput(output: FunctionMemberInput) {
  return translateType(output.type, { UInt: "BigNumber.BigNumber" })
}

let unnamedArgumentNumber = 0

function unnamedArgumentName(): string {
  return `unnamed${unnamedArgumentNumber++}`
}

function buildFunctionArgument(input: FunctionMemberInput): string {
  let name = input.name
  if (name[0] == "_") {
    name = name.slice(1)
  }
  const type = translateType(input.type)

  if (name.length === 0) {
    name = unnamedArgumentName()
  }

  return `${name}: ${type}`
}

function translateType(type: SolidityType, options = { UInt: "UInt" }): string {
  switch (type) {
    case "string":
      return "string"
    case "address":
      return "Address"
    case "address[]":
      return "Address[]"
    case "bool":
      return "boolean"
    case "bytes":
      return "string"
    case "bytes32":
      return "string"
    case "bytes32[]":
      return "string[]"
    case "uint8":
    case "uint32":
    case "uint64":
    case "uint256":
      return options.UInt
    case "uint8[]":
    case "uint256[]":
      return `${options.UInt}[]`
    default:
      throw `Unexpected case! ${type}`
  }
}

function buildEventMember(_member: Member) {
  return ""
}

function buildConstructorMember(_member: Member) {
  return ""
}

function buildFallbackMember(_member: Member) {
  return ""
}

const glob = require("glob")

glob("./build/contracts/*.json", {}, (err: string, files: string[]) => {
  if (err) {
    console.log("Error!", err)
    return
  }

  console.log(generateHeader())
  let contractInstances: string[] = []

  files.forEach((file) => {
    let definition: Definition = require(file)
    contractInstances.push(definition.contractName)
    console.log(buildContract(definition))
  })
  console.log(generateFooter(contractInstances))
})
